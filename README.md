# How Javascript work behind the scene

## რა არის ჯავასკრიპტი?
ეს არის პროგრამული ენა ვებგვერდის დინამიური შინაარსის შესაქმნელად, მისი საშუალებით შეგვიძლია შევქმნათ ელემენტები მომხარებლებისა და ვეგვერდების ურთიერთქმედების გასაუმჯობესებლად მარტივად რომ ვთქვათ ის ეხმარება მომხმარებელს რომ მან იურთიერთოს საიტთან.

## როგორ მუშაობს ჯავასკრიპტი
Javascript is a high-level, prototype-based object-oriented, multi-paradigm, interpreted or just-in-time compiled, dynamic, single-threaded, garbage-collected programming language with first-class functions and non-blocking event loop concurrency model.

კარგი მოდი ეხლა ავხსნათ ყველა აქ ჩამოთვლილი

## High-level 
ანუ მარტივად რო ავხსნათ high-level პროგრამული ენა ნიშნავს რომ მას არ სჭირდება მექანიკურად მეხსიერების მართვა ანუ ჩვენ არ გვჭირდება ვკითხოთ ჩვენს მეხსიერებას მეხსიერებისთვის რომ მაგალითად შევქმნათ რაღაც ცვლადი low-level პროგრამულ ენებს კი ჭირდებათ მექანიკურად რესურსების მექანიკურად მართვა ჯავასკრიპტი ამას კი ავტომატურად აკეთებს, მაგრამ ამას აქვს ცუდი მხარეც high-level პროგრამული ენით გაკეთებული პროგრამა არიქნება ისეთი ოპტიმიზირებული და სწრაფი როგორც low-level_ით.

## Garbage-collected
ჯავასკრიპტი ყველა გამოუყენებლ ობიექტს შლის ავტომატურად ყველა ის რაღაც რაც ჩვენ არ გვჭირდება ავტომატურად იშლება ჩვენი კომპის მეხსიერებიდან.

## Iterpreted or just-in-time compiled
ესეიგი კომპიუტერი როგორც ვიცით კითხულობს ნულებს და ერთებს ეს ასერომვთქვათ ჩვენი მანქანის ენაა ხოლო ჩვენ კი ვწერთ კოდს ადამიანის ენაზე რათქმაუნდა ამ კოდს ჭირდება თარგმანი რასაც ჯავასკრიპტის ძრავა აკეთებს (უფრო მეტი ამაზე მერე).

## Multi-paradigm
ესეიგი პროგრამული პარადიგმი ეს არის გზა რომ ამოხსნა შენი პრობლემა პროგრამული ენების დახმარებით და პარადიგმი შეგვიძლია განვმარტოთ ასე როგორც რაღაც მიდგომა რომ ამოხსნა/გადაჭრა შენი პრობლემა, ჯავასკრიპტს აქვს ასეთი რამოდენიმე მიდგომა ერთ-ერთი არის procedural prorgramming მოკლედ ეს არის უბრალოდ ის გზა რასაც ყოველთვის ვაკეთებთ უბრალოდ კოდის ორგანიზება ძალიან მარტივი გზით და შემდეგ სულ რამოდენიმე ფუნქცია ამის შუაში.

## Prototype-based object-oriented
ესეიგი ეს არის მიდგმომა სადაც გამოსავალი შექმნილია ობიექტებისა და კლასებს შორის კომუნიკაციის გარშემო, რომლებიც ინახავენ მონაცემებს და ამ მონაცემებზე მოქმედების მეთოდებს.

## First-class functions
მოკლედ ჯავასკრიპტს აქვს მაღალი კლასის ფუქნციები ანუ ფუნქციები ჩვენ შეგვიძლია ჩავსვათ ცვალდში ან ერთი ფუნქცია მეორეში და ასშ... ჩვენ ფუნქციები შეგვიძლია მრავალი ხერხით გამოვიყენოთ ჩვენი პრობლემის ამოსახსნელად.

## Dynamic
ჯავასკრიპტი არის დინამიურად წერის ენა ანუ ჩვენ მექანიკურად არ გვჭირდება განვსაზღვროთ ჩვენი ცვლადის ტიპი ამას ჯავასკრიპტი ავტომატურად აკეთებს.

## Single-threaded, non-blocking event loop
concurrency model: ეს უბრალოდ ტერმინია თუ როგორ ართმევს ჯავასკრიპტის ძრავი რამდენიმე თასქზე მუშაობს თავს.

რაში გვჭირდება ეს?

ჯავასკრიპტი ეშვება მხოლოდ ერთ thread_ზე, ასერომ მას შეუძლია გააკეთოს ერთი რაღაც ერთ დროს.

thread ეს უბრალოდ არის ინსტრუქციების ნაკრები რომელიც სრულდება კომპიუტერის cpu_ში, ძირითადად thread არის ის ადგილი სადაც ჩვენი კოდი სრულდება მანქანის პროცესორში.

მაგრამ რახდება თუ ჩვენ გვაქ რაღაც დიდხნიანი თასქი რომელიც ერთ ჯერზე ვერ სრულდება?

ჩვენი ჯავასკრიპტის event loop ამ თასქს შეასრულობს უკანა ფონზე და როდესაც მზად იქნება ის ისევ მთავარ thread_ზე ჩასვავს მას


## რა არის ჯავასკრიპტის ძრავი?
ეს არის ადგილი სადაც სრულდება ჯავასკრიპტის კოდი

ძრავს აქვს ორი რაღაც ესენია Call stack და Heap

Call stack ეს არის ადგილი სადაც სრულდება ჩვენი კოდი execution contexts დახმარებით

ხოლო heap არის ადგილი რომელიც ინახავს ყველა ობიექტს რომელიც საჭიროა ჩვენი აპლიკაციისთვის

## როგორ ითარგმნება ჩვენი კოდი მანქანის ენაზე?
კარგის სანამ დავიწყებთ JIT_ზე საუბარს მანამ უნდა განვიხილოთ ორი რამ ესენია compilation და interpretation

compilation: ეს ჩვენს კოდს თარგმნის მანქანის ენაზე შემდეგომ ეს კოდი იწერება ბინარულ ფაილად(მანქანის კოდი) და შემდეგ უკვე იწყება მისი შესრულება cpu_ში ანუ შესრულება იწყება მისი კომპილაციის შემდეგ, როდესაც შენ რთავ რაიმე აპლიკაციას მისი კოდი უკვე კომპილირებულია და ახლა ასრულებ შენ.

interpretation: ესეიგი აქ სხვანაირადაა ყველაფერი ეს ინტერპრეტერი გადის კოდს და ასრულებს მას line by line აქ გვაქ მხოლოდ ერთი გზა შესრულება რათქმაუნდა კოდს ჭირდება რო გადაკონვერტირდეს მანქანის კოდზე და ეს არხდება შესრულებამდე ეს ხდება შესრულების შემდეგ.

ჯავასკრიტპი ადრე იყო ინტერპრეტერი ენა მაგრამ ასეთი ენები ძალიან ნელები არიან ვიდრე ქომფაილედ ენები ასერომ დღეისთვის ჩვენ გვაქ მიქსი ინტერპრეტერსა და ქომფაილედს შორის ანუ ამათ მიქსი და ამას დაერქვა just-in-time compilation.

JIT: მთელი კოდი კონვერტირდება მანქანის კოდზე ერთხელ და შემდეგ სრულდება მაშინვე.
მოკლედ აქ გვაქ ჩვეულებრივი ისევე ორ ნაბიჯიანი კომპილაცია მაგრამ აღარ გვაქ ბინარული ფაილი და კოდის გაშვება ხდება მაშინვე.

## უფრო სიღრმეში ჩვენი JIT
მოკლედ თავიდან ხდება parsing ანუ კოდის წაკითხვა შემდეგ ხდება ამ კოდის ისეთ მონაცემთა სტრუქტურად წაკითხვა რომელსაც ეწოდება abstract syntax tree(AST) ანუ ამ ast ფაილში განხილულია ჩვენი კოდი მაგალითად რომ ესაა ცვლადი მისი სახელია x და მნიშვნელობა 30 თუმცა აქ სხვა ბევრი რამეა რაც არ დამაინტერესდა, შემდეგ მოდის ჩვენი JIT ანუ ეს AST ფაილი უკვე გადადის კომპილაციაში და ხდება მისი კონვერტირება მანქანის ენაზე შემდეგ უკვე ხდება შესრულება ამ კოდის რომელიც როგორც ვიცით სრულდება call stack_ში და შესრულების დროს ხდება კოდის ოპტიმიზაცია და თავიდან გადაკოვერტირება ეს ხდება რამოდენიმეჯერე და არა ოპტიმიზრებული კოდი შემდეგმ ხდება უფრო ოპტიმიზირებული ეს ყველაფერი ჯავასკრიპტის ძრავს ხდის უფრო სწარფს (V8 ჯავასკრიპტის ძრავი) და ეს ყველაფერი ხდება რაღაც სპეციალურ thread_ზე რომელზეც არ გვაქ ჩვენ წვდომა ჩვენი კოდიდან ასერომ ის გამოყოფილია მთავარი thread_იდან რომელიც ძრითადად მიდის callstack_ში და ასრულებს ჩვენს კოდს.

## Runtime in the browser
ჯავასკრიპტის ბრაუზერში გასაშვებად რათქმაუნდა გვჭირდება ძრავი ვიცით ძრავში რაცაა, ასევე გვჭირდება web Api's ეს არის ფუნქციები რომლებიც განკუთვნილია ჩვენი ძრავისთვის ანუ ესენი შეიძლება იყოს DOM ან ტაიმერები ანდაც console.log() რომელსაც თითქმის სულ ვიყენებთ, შემდეგი არის Callback Queue ანუ ეს ძირითადად ეხება ქოლბექ ფუნქციებს როგორებიცაა მაგალითად click event ანუ რო ვაწვებით რაღაცას და ველოდებით კიდევ რაღაცის მოხდენას ანუ როდესაც ვაწვებით ჩვენ რაღაცას ის პირველად გადადის Callback Queue_ში და შემდეგ ხდება მისი callstack_ში გადატანა event loop_ის დახმარებით ეს იღებს ქოლბექ ფუნქციებს Callback Queue_დან და დებს მათ ქოლსთაქში.



ანუ runtime არის ასერომვთქვათ რაღაც ყუთი რომელშიც არის ყველა ჯავასკრიპტთან დაკავშირებული რაღაცეები.

## რა არის execution context
ეს არის გარემო სადაც ინახება ყველა საჭირო ინფორმაცია კოდისთვის რათა შესრულდეს იგი ესეიგი კომპილაციის შემდეგ მოდის უკვე კოდის შესრულება ამას უფრო სიღრმეში რო ჩავხედოთ თავიდან იქმნება global execution context(op-level კოდისთვის) ანუ კოდისთვის რომელიც არარის ფუნქციაში და ასეთი იქმნება მხოლოდ ერთხელ  და შემდეგ უკვე სრულდება ის ამის შემდეგ იწყება ფუნქციების შესრულება და დალოდება callback_ებისთვის ყველა ფუნქციისთვის იქმნება თითო execution context ყველა ფუნქციის გამოძახებაზე ასევე არიან მეთოდებიც რადგან ესენია ფუქნციები მიმაგრებული ობიექტზე

## რა არის execution context_ში
1) Variable environment
  * let, const and var declaration
  * Functions
  * Arguments object (ყველა ის არგუმენტი რომელასც ჩავწერთ ფუნქციაში და რომელასც მიმდინარე execution context_ი შეიცავს)

2) Scope chain

3) This keyword

ეს ყველაფერი გენერირდება creation phase_ში execution_ის დაწყებამდე.

## The Call Stack









